{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Test Cases with auto": {
		"prefix": "test int",
		"isFileTemplate": true,
		"body": [
			"#ifdef Rahul",
			"#include \"RAHUL.h\"",
			"#else",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define error(...) 42;",
			"#endif",
			"template<typename T> inline bool uax(T &x, T y) {return (y > x) ? x = y, true : false;}",
			"template<typename T> inline bool uin(T &x, T y) {return (y < x) ? x = y, true : false;}",
			"#define Luv(...) [&] (auto &&u, auto &&v) { return __VA_ARGS__; }",
			"using i64 = int64_t;",
			"",
			"auto SolveCase() {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  cin.tie(nullptr) -> sync_with_stdio(false);",
			"  int tt; cin >> tt;",
			"  while (tt--) cout << SolveCase() << '\\n';",
			"}"
		],
	},
	"Test Cases with bool": {
		"prefix": "test bool",
		"isFileTemplate": true,
		"body": [
			"#ifdef Rahul",
			"#include \"RAHUL.h\"",
			"#else",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define error(...) 42;",
			"#endif",
			"template<typename T> inline bool uax(T &x, T y) {return (y > x) ? x = y, true : false;}",
			"template<typename T> inline bool uin(T &x, T y) {return (y < x) ? x = y, true : false;}",
			"#define Luv(...) [&] (auto &&u, auto &&v) { return __VA_ARGS__; }",
			"using i64 = int64_t;",
			"",
			"bool SolveCase() {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  cin.tie(nullptr) -> sync_with_stdio(false);",
			"  int tt; cin >> tt;",
			"  while (tt--) cout << (SolveCase() ? \"Yes\" : \"No\") << '\\n';",
			"}"
		],
	},
	"Test Case single": {
		"prefix": "test single",
		"isFileTemplate": true,
		"body": [
			"#ifdef Rahul",
			"#include \"RAHUL.h\"",
			"#else",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define error(...) 42;",
			"#endif",
			"template<typename T> inline bool uax(T &x, T y) {return (y > x) ? x = y, true : false;}",
			"template<typename T> inline bool uin(T &x, T y) {return (y < x) ? x = y, true : false;}",
			"#define Luv(...) [&] (auto &&u, auto &&v) { return __VA_ARGS__; }",
			"using i64 = int64_t;",
			"",
			"int main() {",
			"  cin.tie(nullptr) -> sync_with_stdio(false);",
			"  $0",
			"}"
		],
	},
	"Test Cases with void": {
		"prefix": "test void",
		"isFileTemplate": true,
		"body": [
			"#ifdef Rahul",
			"#include \"RAHUL.h\"",
			"#else",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define error(...) 42;",
			"#endif",
			"template<typename T> inline bool uax(T &x, T y) {return (y > x) ? x = y, true : false;}",
			"template<typename T> inline bool uin(T &x, T y) {return (y < x) ? x = y, true : false;}",
			"#define Luv(...) [&] (auto &&u, auto &&v) { return __VA_ARGS__; }",
			"using i64 = int64_t;",
			"",
			"void SolveCase() {",
			"  $0",
			"}",
			"",
			"int main() {",
			"  cin.tie(nullptr) -> sync_with_stdio(false);",
			"  int tt; cin >> tt;",
			"  while (tt--) SolveCase();",
			"}"
		],
	},
	"Test Case z clean": {
    "prefix": "test clean",
		"isFileTemplate": true,
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"  $0",
			"}",
			""
		]
	},
	"Modulus": {
		"prefix": "zzmod",
		"body": [
			"#include <atcoder/modint>",
			"using Mint = ::atcoder::modint1000000007;",
			"using Mint = ::atcoder::modint998244353;"
		]
	},
	"Prime sieve": {
		"prefix": "zzprime",
		"body": [
			"const int M = 1e6 + 42;",
			"array<int, M> lpf;",
			"auto primes = [](){",
			"  vector<int> p;",
			"  iota(lpf.begin(), lpf.end(), 0);",
			"  for (int i = 2; i < M; ++i) {",
			"    if (lpf[i] == i) {",
			"      p.push_back(i);",
			"      for (int j = i + i; j < M; j += i) {",
			"        if (lpf[j] == j) lpf[j] = i;",
			"      }",
			"    }",
			"  }",
			"  return p;",
			"}();",
			""
		]
	},
	"Read graph": {
		"prefix": "zzgraph",
		"body": [
			"vector<vector<int>> g(n);",
			"for (int i = 0; i < n - 1; ++i) {",
			"  int u, v; cin >> u >> v; --u, --v;",
			"  g[u].push_back(v);",
			"  g[v].push_back(u);",
			"}",
			"auto dfs = [&] (this auto&& dfs, int u, int p) -> void {",
			"  for (int v : g[u]) if (v != p) {",
			"    dfs(v, u);",
			"  }",
			"};",
			"dfs(0, -1);"
		],
		"description": "Read graph"
	},
	"Combinatorics": {
  "prefix": "zzcomb",
  "body": [
    "#include <atcoder/modint>",
    "using Mint = ::atcoder::modint1000000007;",
    "using Mint = ::atcoder::modint998244353;",
    "",
    "vector<Mint> fact = {1}, ifact = {1};",
    "",
    "Mint Fact(int i) {",
    "  while (fact.size() <= i) fact.push_back(fact.back() * fact.size());",
    "  return fact[i];",
    "}",
    "",
    "Mint Ifact(int i) {",
    "  while (ifact.size() <= i) ifact.push_back(ifact.back() / ifact.size());",
    "  return ifact[i];",
    "}",
    "",
    "Mint C(int n, int r) {",
    "  if (n < r || r < 0 || n < 0) return 0;",
    "  return Fact(n) * Ifact(n - r) * Ifact(r);",
    "}",
    "",
    "Mint Cbig(long long n, long long r){",
    "  if (n < r || r < 0 || n < 0) return 0;",
    "  r = min(r, n - r);",
    "  Mint res = 1;",
    "  for(auto i = n; i > n - r; --i) res *= i;",
    "  return res * Ifact(r);",
    "}"
  ],
  "description": "Combinatorics"
}
}